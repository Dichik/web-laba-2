{"ast":null,"code":"\"use strict\";\n\nvar MemoryStore = require(\"./memory-store\");\n\nfunction RateLimit(options) {\n  options = Object.assign({\n    windowMs: 60 * 1000,\n    // milliseconds - how long to keep records of requests in memory\n    max: 5,\n    // max number of recent connections during `window` milliseconds before sending a 429 response\n    message: \"Too many requests, please try again later.\",\n    statusCode: 429,\n    // 429 status = Too Many Requests (RFC 6585)\n    headers: true,\n    //Send custom rate limit header with limit and remaining\n    draft_polli_ratelimit_headers: false,\n    //Support for the new RateLimit standardization headers\n    // ability to manually decide if request was successful. Used when `skipSuccessfulRequests` and/or `skipFailedRequests` are set to `true`\n    requestWasSuccessful: function requestWasSuccessful(req, res) {\n      return res.statusCode < 400;\n    },\n    skipFailedRequests: false,\n    // Do not count failed requests\n    skipSuccessfulRequests: false,\n    // Do not count successful requests\n    // allows to create custom keys (by default user IP is used)\n    keyGenerator: function keyGenerator(req\n    /*, res*/\n    ) {\n      if (!req.ip) {\n        console.error(\"express-rate-limit: req.ip is undefined - you can avoid this by providing a custom keyGenerator function, but it may be indicative of a larger issue.\");\n      }\n\n      return req.ip;\n    },\n    skip: function\n      /*req, res*/\n    skip() {\n      return false;\n    },\n    handler: function handler(req, res\n    /*, next, optionsUsed*/\n    ) {\n      res.status(options.statusCode).send(options.message);\n    },\n    onLimitReached: function\n      /*req, res, optionsUsed*/\n    onLimitReached() {},\n    requestPropertyName: \"rateLimit\" // Parameter name appended to req object\n\n  }, options); // store to use for persisting rate limit data\n\n  options.store = options.store || new MemoryStore(options.windowMs); // ensure that the store has the incr method\n\n  if (typeof options.store.incr !== \"function\" || typeof options.store.resetKey !== \"function\" || options.skipFailedRequests && typeof options.store.decrement !== \"function\") {\n    throw new Error(\"The store is not valid.\");\n  }\n\n  [\"global\", \"delayMs\", \"delayAfter\"].forEach(function (key) {\n    // note: this doesn't trigger if delayMs or delayAfter are set to 0, because that essentially disables them\n    if (options[key]) {\n      throw new Error(\"The \".concat(key, \" option was removed from express-rate-limit v3.\"));\n    }\n  });\n\n  function rateLimit(req, res, next) {\n    Promise.resolve(options.skip(req, res)).then(function (skip) {\n      if (skip) {\n        return next();\n      }\n\n      var key = options.keyGenerator(req, res);\n      options.store.incr(key, function (err, current, resetTime) {\n        if (err) {\n          return next(err);\n        }\n\n        var maxResult = typeof options.max === \"function\" ? options.max(req, res) : options.max;\n        Promise.resolve(maxResult).then(function (max) {\n          req[options.requestPropertyName] = {\n            limit: max,\n            current: current,\n            remaining: Math.max(max - current, 0),\n            resetTime: resetTime\n          };\n\n          if (options.headers && !res.headersSent) {\n            res.setHeader(\"X-RateLimit-Limit\", max);\n            res.setHeader(\"X-RateLimit-Remaining\", req[options.requestPropertyName].remaining);\n\n            if (resetTime instanceof Date) {\n              // if we have a resetTime, also provide the current date to help avoid issues with incorrect clocks\n              res.setHeader(\"Date\", new Date().toUTCString());\n              res.setHeader(\"X-RateLimit-Reset\", Math.ceil(resetTime.getTime() / 1000));\n            }\n          }\n\n          if (options.draft_polli_ratelimit_headers && !res.headersSent) {\n            res.setHeader(\"RateLimit-Limit\", max);\n            res.setHeader(\"RateLimit-Remaining\", req[options.requestPropertyName].remaining);\n\n            if (resetTime) {\n              var deltaSeconds = Math.ceil((resetTime.getTime() - Date.now()) / 1000);\n              res.setHeader(\"RateLimit-Reset\", Math.max(0, deltaSeconds));\n            }\n          }\n\n          if (options.skipFailedRequests || options.skipSuccessfulRequests) {\n            var decremented = false;\n\n            var decrementKey = function decrementKey() {\n              if (!decremented) {\n                options.store.decrement(key);\n                decremented = true;\n              }\n            };\n\n            if (options.skipFailedRequests) {\n              res.on(\"finish\", function () {\n                if (!options.requestWasSuccessful(req, res)) {\n                  decrementKey();\n                }\n              });\n              res.on(\"close\", function () {\n                if (!res.finished) {\n                  decrementKey();\n                }\n              });\n              res.on(\"error\", function () {\n                return decrementKey();\n              });\n            }\n\n            if (options.skipSuccessfulRequests) {\n              res.on(\"finish\", function () {\n                if (options.requestWasSuccessful(req, res)) {\n                  options.store.decrement(key);\n                }\n              });\n            }\n          }\n\n          if (max && current === max + 1) {\n            options.onLimitReached(req, res, options);\n          }\n\n          if (max && current > max) {\n            if (options.headers && !res.headersSent) {\n              res.setHeader(\"Retry-After\", Math.ceil(options.windowMs / 1000));\n            }\n\n            return options.handler(req, res, next, options);\n          }\n\n          next();\n          return null;\n        }).catch(next);\n      });\n      return null;\n    }).catch(next);\n  }\n\n  rateLimit.resetKey = options.store.resetKey.bind(options.store); // Backward compatibility function\n\n  rateLimit.resetIp = rateLimit.resetKey;\n  return rateLimit;\n}\n\nmodule.exports = RateLimit;","map":{"version":3,"sources":["/home/dichik/PhpstormProjects/web-laba-2/my-app/node_modules/express-rate-limit/lib/express-rate-limit.js"],"names":["MemoryStore","require","RateLimit","options","Object","assign","windowMs","max","message","statusCode","headers","draft_polli_ratelimit_headers","requestWasSuccessful","req","res","skipFailedRequests","skipSuccessfulRequests","keyGenerator","ip","console","error","skip","handler","status","send","onLimitReached","requestPropertyName","store","incr","resetKey","decrement","Error","forEach","key","rateLimit","next","Promise","resolve","then","err","current","resetTime","maxResult","limit","remaining","Math","headersSent","setHeader","Date","toUTCString","ceil","getTime","deltaSeconds","now","decremented","decrementKey","on","finished","catch","bind","resetIp","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\nconst MemoryStore = require(\"./memory-store\");\n\nfunction RateLimit(options) {\n  options = Object.assign(\n    {\n      windowMs: 60 * 1000, // milliseconds - how long to keep records of requests in memory\n      max: 5, // max number of recent connections during `window` milliseconds before sending a 429 response\n      message: \"Too many requests, please try again later.\",\n      statusCode: 429, // 429 status = Too Many Requests (RFC 6585)\n      headers: true, //Send custom rate limit header with limit and remaining\n      draft_polli_ratelimit_headers: false, //Support for the new RateLimit standardization headers\n      // ability to manually decide if request was successful. Used when `skipSuccessfulRequests` and/or `skipFailedRequests` are set to `true`\n      requestWasSuccessful: function (req, res) {\n        return res.statusCode < 400;\n      },\n      skipFailedRequests: false, // Do not count failed requests\n      skipSuccessfulRequests: false, // Do not count successful requests\n      // allows to create custom keys (by default user IP is used)\n      keyGenerator: function (req /*, res*/) {\n        if (!req.ip) {\n          console.error(\n            \"express-rate-limit: req.ip is undefined - you can avoid this by providing a custom keyGenerator function, but it may be indicative of a larger issue.\"\n          );\n        }\n        return req.ip;\n      },\n      skip: function (/*req, res*/) {\n        return false;\n      },\n      handler: function (req, res /*, next, optionsUsed*/) {\n        res.status(options.statusCode).send(options.message);\n      },\n      onLimitReached: function (/*req, res, optionsUsed*/) {},\n      requestPropertyName: \"rateLimit\", // Parameter name appended to req object\n    },\n    options\n  );\n\n  // store to use for persisting rate limit data\n  options.store = options.store || new MemoryStore(options.windowMs);\n\n  // ensure that the store has the incr method\n  if (\n    typeof options.store.incr !== \"function\" ||\n    typeof options.store.resetKey !== \"function\" ||\n    (options.skipFailedRequests &&\n      typeof options.store.decrement !== \"function\")\n  ) {\n    throw new Error(\"The store is not valid.\");\n  }\n\n  [\"global\", \"delayMs\", \"delayAfter\"].forEach((key) => {\n    // note: this doesn't trigger if delayMs or delayAfter are set to 0, because that essentially disables them\n    if (options[key]) {\n      throw new Error(\n        `The ${key} option was removed from express-rate-limit v3.`\n      );\n    }\n  });\n\n  function rateLimit(req, res, next) {\n    Promise.resolve(options.skip(req, res))\n      .then((skip) => {\n        if (skip) {\n          return next();\n        }\n\n        const key = options.keyGenerator(req, res);\n\n        options.store.incr(key, function (err, current, resetTime) {\n          if (err) {\n            return next(err);\n          }\n\n          const maxResult =\n            typeof options.max === \"function\"\n              ? options.max(req, res)\n              : options.max;\n\n          Promise.resolve(maxResult)\n            .then((max) => {\n              req[options.requestPropertyName] = {\n                limit: max,\n                current: current,\n                remaining: Math.max(max - current, 0),\n                resetTime: resetTime,\n              };\n\n              if (options.headers && !res.headersSent) {\n                res.setHeader(\"X-RateLimit-Limit\", max);\n                res.setHeader(\n                  \"X-RateLimit-Remaining\",\n                  req[options.requestPropertyName].remaining\n                );\n                if (resetTime instanceof Date) {\n                  // if we have a resetTime, also provide the current date to help avoid issues with incorrect clocks\n                  res.setHeader(\"Date\", new Date().toUTCString());\n                  res.setHeader(\n                    \"X-RateLimit-Reset\",\n                    Math.ceil(resetTime.getTime() / 1000)\n                  );\n                }\n              }\n              if (options.draft_polli_ratelimit_headers && !res.headersSent) {\n                res.setHeader(\"RateLimit-Limit\", max);\n                res.setHeader(\n                  \"RateLimit-Remaining\",\n                  req[options.requestPropertyName].remaining\n                );\n                if (resetTime) {\n                  const deltaSeconds = Math.ceil(\n                    (resetTime.getTime() - Date.now()) / 1000\n                  );\n                  res.setHeader(\"RateLimit-Reset\", Math.max(0, deltaSeconds));\n                }\n              }\n\n              if (\n                options.skipFailedRequests ||\n                options.skipSuccessfulRequests\n              ) {\n                let decremented = false;\n                const decrementKey = () => {\n                  if (!decremented) {\n                    options.store.decrement(key);\n                    decremented = true;\n                  }\n                };\n\n                if (options.skipFailedRequests) {\n                  res.on(\"finish\", function () {\n                    if (!options.requestWasSuccessful(req, res)) {\n                      decrementKey();\n                    }\n                  });\n\n                  res.on(\"close\", () => {\n                    if (!res.finished) {\n                      decrementKey();\n                    }\n                  });\n\n                  res.on(\"error\", () => decrementKey());\n                }\n\n                if (options.skipSuccessfulRequests) {\n                  res.on(\"finish\", function () {\n                    if (options.requestWasSuccessful(req, res)) {\n                      options.store.decrement(key);\n                    }\n                  });\n                }\n              }\n\n              if (max && current === max + 1) {\n                options.onLimitReached(req, res, options);\n              }\n\n              if (max && current > max) {\n                if (options.headers && !res.headersSent) {\n                  res.setHeader(\n                    \"Retry-After\",\n                    Math.ceil(options.windowMs / 1000)\n                  );\n                }\n                return options.handler(req, res, next, options);\n              }\n\n              next();\n\n              return null;\n            })\n            .catch(next);\n        });\n\n        return null;\n      })\n      .catch(next);\n  }\n\n  rateLimit.resetKey = options.store.resetKey.bind(options.store);\n\n  // Backward compatibility function\n  rateLimit.resetIp = rateLimit.resetKey;\n\n  return rateLimit;\n}\n\nmodule.exports = RateLimit;\n"]},"metadata":{},"sourceType":"script"}